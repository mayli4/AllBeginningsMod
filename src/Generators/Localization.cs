using Generators.Utilities;

using Microsoft.CodeAnalysis;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

using Hjson;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Generators;

[Generator(LanguageNames.CSharp)]
internal sealed class LocalizationGenerator : IIncrementalGenerator {
    private const string hjson_extension = ".hjson";
    private const string mod_name = "AllBeginningsMod";

    private static readonly Regex arg_remapping_regex = new(@"(?<={\^?)(\d+)(?=(?::[^\r\n]+?)?})", RegexOptions.Compiled);

    private static readonly string initial_file_header;
    
    /// <summary>
    ///     A single localization key and its derived properties.
    /// </summary>
    /// <param name="FullKey"> The full localization key. (eg. Mods.MyMod.Items.CoolItem.DisplayName) </param>
    /// <param name="Name"> The name of the entry. (eg. .DisplayName) </param>
    internal readonly record struct Entry(string FullKey, string Name, string Value, int ArgCount);

    /// <summary>
    ///     A node in the structure of localization keys.
    /// </summary>
    internal sealed class Node {
        public string Name { get; }
        public string FullKeyPrefix { get; }
        public List<Entry> Entries { get; } = new();
        public Dictionary<string, Node> ChildNodes { get; } = new();

        public Node(string name, string fullKeyPrefix) {
            Name = name;
            FullKeyPrefix = fullKeyPrefix;
        }
    }

    static LocalizationGenerator() {
        var writer = new IndentedStringWriter(512);
        writer.WriteLine("// <auto-generated/>");

        writer.WriteLine(@"
#nullable enable

using Terraria.Localization;
using System;
using System.Linq;
");

        writer.WriteLine($"namespace {mod_name}.Localization;");

        initial_file_header = writer.ToStringAndClear();
    }

    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context) {
        var allLocalizationEntries = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith(hjson_extension, StringComparison.OrdinalIgnoreCase))
            .SelectMany(static (file, cancellationToken) => GetKeysFromFile(file, cancellationToken))
            .Collect();

        var categorizedLocalizationData = allLocalizationEntries
            .SelectMany(static (entries, cancellationToken) => {
                return entries
                    .Where(entry => entry.FullKey.StartsWith($"Mods.{mod_name}.", StringComparison.OrdinalIgnoreCase))
                    .Select(entry => {
                        string relativeToModKey = entry.FullKey.Substring($"Mods.{mod_name}.".Length);
                        string topLevelCategory = relativeToModKey.Split('.').FirstOrDefault();
                        return (topLevelCategory, entry);
                    })
                    .Where(x => !string.IsNullOrEmpty(x.topLevelCategory))
                    .GroupBy(x => x.topLevelCategory, x => x.entry)
                    .Select(group => (group.Key, group.ToImmutableArray()))
                    .ToImmutableArray();
            });

        context.RegisterSourceOutput(
            categorizedLocalizationData,
            (sourceContext, categoryGroup) => {
                sourceContext.CancellationToken.ThrowIfCancellationRequested();

                var (topLevelCategory, categoryEntries) = categoryGroup;

                var categoryRootNode = new Node(topLevelCategory, $"Mods.{mod_name}.{topLevelCategory}");

                foreach (var entry in categoryEntries.OrderBy(e => e.FullKey)) {
                    sourceContext.CancellationToken.ThrowIfCancellationRequested();

                    string relativeToCategoryKey = entry.FullKey.Substring($"Mods.{mod_name}.{topLevelCategory}.".Length);
                    var parts = relativeToCategoryKey.Split('.');
                    var currentNode = categoryRootNode;

                    string currentFullKeyPrefix = categoryRootNode.FullKeyPrefix;

                    for (var i = 0; i < parts.Length; i++) {
                        var part = parts[i];
                        if (string.IsNullOrEmpty(part)) continue;

                        string nextFullKeySegment = string.IsNullOrWhiteSpace(currentFullKeyPrefix) ? part : $"{currentFullKeyPrefix}.{part}";

                        if (i == parts.Length - 1) {
                            currentNode.Entries.Add(entry);
                        }
                        else {
                            if (!currentNode.ChildNodes.TryGetValue(part, out var childNode)) {
                                childNode = new Node(part, nextFullKeySegment);
                                currentNode.ChildNodes.Add(part, childNode);
                            }
                            currentNode = childNode;
                            currentFullKeyPrefix = nextFullKeySegment;
                        }
                    }
                }

                using IndentedStringWriter writer = new(4096);
                writer.WriteLine(initial_file_header);

                writer.BeginScope($"public static partial class Keys");

                GenerateClassForNode(writer, categoryRootNode, 0);

                writer.EndScope();

                string sourceText = writer.ToStringAndClear();

                string fileName = $"_Localization.Keys.{topLevelCategory}.g.cs";

                string emptyCategoryContent = $"{initial_file_header.Trim()}\n\npublic static partial class Keys {{\n\n}}\n";
                if (categoryEntries.Length == 0 || string.IsNullOrWhiteSpace(sourceText) || sourceText.Trim().Equals(emptyCategoryContent.Trim(), StringComparison.OrdinalIgnoreCase)) {
                    sourceContext.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "LGEN201",
                            title: "Localization Generator produced empty category file",
                            messageFormat: "Localization Generator created an empty file for category '{0}' in mod '{1}'. No valid localization keys were found for this category.",
                            category: "LocalizationGenerator",
                            defaultSeverity: DiagnosticSeverity.Warning,
                            isEnabledByDefault: true),
                        Location.None,
                        topLevelCategory,
                        mod_name));
                }
                else
                {
                    sourceContext.AddSource(fileName, sourceText);
                }
            }
        );
    }

    private static void GenerateClassForNode(IndentedStringWriter writer, Node node, int depth) {
        writer.BeginScope($"public static partial class {node.Name}");

        writer.WriteLine($"public const string KEY = \"{node.FullKeyPrefix}\";");
        writer.WriteLine();

        writer.WriteLine("public static LocalizedText GetText() => Language.GetText(KEY);");
        writer.WriteLine("public static string GetTextValue(params object?[] values) => Language.GetTextValue(KEY, values);");
        writer.WriteLine();

        foreach (var entry in node.Entries.OrderBy(e => e.Name)) {
            writer.BeginScope($"public static partial class {entry.Name}");
            writer.WriteLine($"public const string KEY = \"{entry.FullKey}\";");
            writer.WriteLine($"public const int ARG_COUNT = {entry.ArgCount};");
            writer.WriteLine();

            writer.WriteLine("public static LocalizedText GetText() => Language.GetText(KEY);");

            if (entry.ArgCount == 0) {
                writer.WriteLine("public static string GetTextValue() => Language.GetTextValue(KEY);");
            }
            else {
                var argNames = Enumerable.Range(0, entry.ArgCount).Select(i => $"object? arg{i}").ToList();
                var argParams = string.Join(", ", argNames);
                var argValues = string.Join(", ", Enumerable.Range(0, entry.ArgCount).Select(i => $"arg{i}"));
                writer.WriteLine($"public static string GetTextValue({argParams}) => Language.GetTextValue(KEY, {argValues});");
            }
            writer.EndScope();
        }

        foreach (var child in node.ChildNodes.Values.OrderBy(n => n.Name))
        {
            GenerateClassForNode(writer, child, depth + 1);
        }

        writer.EndScope();
    }

    private static IEnumerable<Entry> GetKeysFromFile(AdditionalText file, CancellationToken cancellationToken)
    {
        var keys = new List<Entry>();
        var text = file.GetText(cancellationToken)?.ToString();

        if (string.IsNullOrWhiteSpace(text)) {
            return Enumerable.Empty<Entry>();
        }

        try {
            var json = HjsonValue.Parse(text).ToString();
            var jsonObject = JObject.Parse(json);

            foreach (var token in jsonObject.SelectTokens("$..*")) {
                cancellationToken.ThrowIfCancellationRequested();
                
                if (token is JObject { Count: 0 } || token is JArray { Count: 0 } || token.HasValues) {
                    continue;
                }

                var pathBuilder = new StringBuilder();
                var parents = new Stack<string>();
                var current = token;
                while (current.Parent != null) {
                    if (current.Parent is JProperty property)
                    {
                        parents.Push(property.Name);
                    }
                    current = current.Parent;
                }

                while(parents.Count > 0) {
                    string segment = parents.Pop();
                    if (pathBuilder.Length > 0)
                        pathBuilder.Append('.');
                    pathBuilder.Append(segment);
                }
                
                var fullKey = pathBuilder.ToString();
                string name = fullKey.Split('.').Last(); 

                var value = token.Type switch {
                    JTokenType.String => token.Value<string>() ?? "",
                    JTokenType.Integer => token.Value<long>().ToString(CultureInfo.InvariantCulture),
                    JTokenType.Boolean => token.Value<bool>().ToString(CultureInfo.InvariantCulture),
                    JTokenType.Float => token.Value<double>().ToString(CultureInfo.InvariantCulture),
                    _ => token.ToString(Formatting.None)
                };
                
                int argCount = GetArgumentCount(value);

                keys.Add(new Entry(fullKey, name, value, argCount));
            }
        }
        catch (Exception)
        {
            
        }

        return keys;
    }
    private static int GetArgumentCount(string value)
    {
        var matches = arg_remapping_regex.Matches(value);
        var uniqueArgIndices = new HashSet<int>();

        foreach (Match match in matches)
        {
            if (int.TryParse(match.Groups[1].Value, out int argIndex))
            {
                uniqueArgIndices.Add(argIndex);
            }
        }

        return uniqueArgIndices.Any() ? uniqueArgIndices.Max() + 1 : 0;
    }
}